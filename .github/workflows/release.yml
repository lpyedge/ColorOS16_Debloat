name: Package and Publish Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g. v1.2.3)'
        required: true
      release_name:
        description: 'Release title (optional)'
        required: false
      body:
        description: 'Release notes (optional)'
        required: false
      prerelease:
        description: 'Mark as prerelease (true/false)'
        required: false
        default: 'false'

permissions:
  contents: write

jobs:
  package-and-release:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Bump versionCode, update module.prop and latest.json, and push
        id: prepare
        env:
          TAG: ${{ github.event.inputs.tag }}
          REPO: ${{ github.repository }}
          BODY: ${{ github.event.inputs.body }}
        run: |
          set -euo pipefail

          if [ -z "${TAG}" ]; then
            echo "Release tag input (e.g. v0.0.4) is required" >&2
            exit 1
          fi

          version=${TAG#v}
          if [ -z "$version" ]; then
            echo "Unable to derive version from tag ${TAG}" >&2
            exit 1
          fi
          zip_name="ColorOS16_Debloat-${version}.zip"

          # read existing versionCode from module.prop (default 0)
          if [ -f module.prop ]; then
            existing_vc_line=$(grep -E '^versionCode=' module.prop || true)
            existing_vc=${existing_vc_line#*=}
            existing_vc=${existing_vc:-0}
          else
            echo "module.prop not found!" >&2
            exit 1
          fi

          # increment versionCode
          new_vc=$((existing_vc + 1))

          echo "Bumping versionCode: ${existing_vc} -> ${new_vc}, setting version=${version}"

          # update or add version and versionCode in module.prop
          if grep -q "^version=" module.prop; then
            sed -i -E "s/^version=.*/version=${version}/" module.prop
          else
            echo "version=${version}" >> module.prop
          fi
          if grep -q "^versionCode=" module.prop; then
            sed -i -E "s/^versionCode=.*/versionCode=${new_vc}/" module.prop
          else
            echo "versionCode=${new_vc}" >> module.prop
          fi
          
          # Update version in customize.sh
          if [ -f customize.sh ]; then
             sed -i -E "s/ui_print \" 版本: .*\"/ui_print \" 版本: ${version}\"/" customize.sh
          fi

          # update download_name and update_url to the versioned zip / latest zip for Magisk Manager
          new_download_name="${zip_name}"
          if grep -q "^download_name=" module.prop; then
            sed -i -E "s/^download_name=.*/download_name=${new_download_name}/" module.prop
          else
            echo "download_name=${new_download_name}" >> module.prop
          fi
          # set update_url to raw latest.json (JSON format) for Magisk Manager compatibility
          owner=$(echo "${REPO}" | cut -d/ -f1)
          repo_name=$(echo "${REPO}" | cut -d/ -f2)
          new_update_url="https://raw.githubusercontent.com/${owner}/${repo_name}/main/webroot/latest.json"
          changelog_url="https://raw.githubusercontent.com/${owner}/${repo_name}/main/webroot/changelog.md"
          
          if grep -q "^update_url=" module.prop; then
            sed -i -E "s|^update_url=.*|update_url=${new_update_url}|" module.prop
          else
            echo "update_url=${new_update_url}" >> module.prop
          fi
          if grep -q "^updateJson=" module.prop; then
            sed -i -E "s|^updateJson=.*|updateJson=${new_update_url}|" module.prop
          else
            echo "updateJson=${new_update_url}" >> module.prop
          fi

          # Write changelog to webroot/changelog.md
          echo "${BODY}" > webroot/changelog.md

          # prepare latest.json
          zip_url="https://github.com/${REPO}/releases/download/${TAG}/${zip_name}"
          # create JSON via Python to safely handle escaping and changelog
          export version=${version}
          export versionCode=${new_vc}
          export download_name=${new_download_name}
          export zip_url=${zip_url}
          export changelog_url=${changelog_url}
          python - <<'PY' > webroot/latest.json
          import os, json
          data = {
            "id": "coloros16_debloat",
            "name": "ColorOS 16 Debloat (Ads / Cloud / Stats)",
            "version": os.environ.get('version',''),
            "versionCode": int(os.environ.get('versionCode','0')),
            "download_name": os.environ.get('download_name',''),
            "zipUrl": os.environ.get('zip_url',''),
            "zip_url": os.environ.get('zip_url',''),
            "downloadUrl": os.environ.get('zip_url',''),
            "download_url": os.environ.get('zip_url',''),
            "changelog": os.environ.get('changelog_url','')
          }
          print(json.dumps(data, ensure_ascii=False))
          PY

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add module.prop webroot/latest.json webroot/changelog.md customize.sh
          git commit -m "chore(release): bump versionCode to ${new_vc} for ${version}" || echo "no changes to commit"
          git push origin HEAD:main || echo "push failed"

          {
            echo "version=${version}"
            echo "zip_name=${zip_name}"
            echo "version_code=${new_vc}"
            echo "tag=${TAG}"
          } >> "$GITHUB_OUTPUT"

      - name: Create versioned + latest ZIP packages
        env:
          VERSION: ${{ steps.prepare.outputs.version }}
          ZIP_NAME: ${{ steps.prepare.outputs.zip_name }}
        run: |
          # Create a versioned zip of repo root (exclude git & workflows)
          rm -f ColorOS16_Debloat-*.zip
          version=${VERSION:-}
          if [ -z "$version" ]; then
            echo "Missing VERSION metadata from prepare step" >&2
            exit 1
          fi
          zip_name=${ZIP_NAME:-ColorOS16_Debloat-${version}.zip}
          zip -r "$zip_name" . -x "./.git/*" "./.github/*"
          # create an unversioned 'latest' zip so update_url can point to a stable filename
          cp "$zip_name" ColorOS16_Debloat.zip

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.event.inputs.tag }}
          release_name: ${{ github.event.inputs.release_name || github.event.inputs.tag }}
          body: ${{ github.event.inputs.body }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload latest (unversioned) release asset
        if: always()
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ColorOS16_Debloat.zip
          asset_name: ColorOS16_Debloat.zip
          asset_content_type: application/zip

      - name: Upload versioned release asset
        if: always()
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.prepare.outputs.zip_name }}
          asset_name: ${{ steps.prepare.outputs.zip_name }}
          asset_content_type: application/zip

      # latest.json already updated and pushed before packaging
