name: Publish Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g. 0.5.0, will auto-prefix with v for tag)'
        required: true
        type: string
      release_name:
        description: 'Release title (optional, defaults to version)'
        required: false
        type: string
      body:
        description: 'Release notes (optional, defaults to latest commit)'
        required: false
        type: string
      prerelease:
        description: 'Mark as prerelease'
        required: false
        type: boolean
        default: false
      clean_history:
        description: 'Clean old releases and tags (keep only latest)'
        required: false
        type: boolean
        default: true

permissions:
  contents: write

jobs:
  package-and-release:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0  # fetch all history for tag cleanup

      - name: Clean old releases and tags
        if: ${{ github.event.inputs.clean_history == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "Cleaning old releases and tags..."
          
          # Get all releases and delete them
          gh release list --limit 100 --json tagName --jq '.[].tagName' | while read -r tag; do
            echo "Deleting release: $tag"
            gh release delete "$tag" --yes --cleanup-tag || echo "Failed to delete release $tag"
          done
          
          # Get all remaining tags and delete them
          git tag -l | while read -r tag; do
            echo "Deleting tag: $tag"
            git push origin --delete "$tag" || echo "Failed to delete remote tag $tag"
            git tag -d "$tag" || echo "Failed to delete local tag $tag"
          done
          
          echo "History cleanup completed"

      - name: Bump versionCode, update module.prop and latest.json, and push
        id: prepare
        env:
          VERSION_INPUT: ${{ github.event.inputs.version }}
          REPO: ${{ github.repository }}
          BODY: ${{ github.event.inputs.body }}
        run: |
          set -euo pipefail

          # Validate and normalize version
          version="${VERSION_INPUT}"
          if [ -z "$version" ]; then
            echo "Version input is required (e.g. 0.5.0)" >&2
            exit 1
          fi
          
          # Remove 'v' prefix if user provided it
          version="${version#v}"
          
          # Validate version format (simple check for x.y.z)
          if ! echo "$version" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Invalid version format: $version. Expected format: x.y.z (e.g. 0.5.0)" >&2
            exit 1
          fi
          
          tag="v${version}"
          zip_name="ColorOS16_Debloat-${version}.zip"

          # read existing versionCode from module.prop (default 0)
          if [ -f module.prop ]; then
            existing_vc_line=$(grep -E '^versionCode=' module.prop || true)
            existing_vc=${existing_vc_line#*=}
            existing_vc=${existing_vc:-0}
          else
            echo "module.prop not found!" >&2
            exit 1
          fi

          # increment versionCode
          new_vc=$((existing_vc + 1))

          echo "Version: ${version}"
          echo "Tag: ${tag}"
          echo "Bumping versionCode: ${existing_vc} -> ${new_vc}"

          # update or add version and versionCode in module.prop
          if grep -q "^version=" module.prop; then
            sed -i -E "s/^version=.*/version=${version}/" module.prop
          else
            echo "version=${version}" >> module.prop
          fi
          if grep -q "^versionCode=" module.prop; then
            sed -i -E "s/^versionCode=.*/versionCode=${new_vc}/" module.prop
          else
            echo "versionCode=${new_vc}" >> module.prop
          fi
          
          # Update version in customize.sh
          if [ -f customize.sh ]; then
             sed -i -E "s/ui_print \" 版本: .*\"/ui_print \" 版本: ${version}\"/" customize.sh
          fi

          # update download_name and update_url to the versioned zip / latest zip for Magisk Manager
          new_download_name="${zip_name}"
          if grep -q "^download_name=" module.prop; then
            sed -i -E "s/^download_name=.*/download_name=${new_download_name}/" module.prop
          else
            echo "download_name=${new_download_name}" >> module.prop
          fi
          # set update_url to raw latest.json (JSON format) for Magisk Manager compatibility
          owner=$(echo "${REPO}" | cut -d/ -f1)
          repo_name=$(echo "${REPO}" | cut -d/ -f2)
          new_update_url="https://raw.githubusercontent.com/${owner}/${repo_name}/main/webroot/latest.json"
          changelog_url="https://raw.githubusercontent.com/${owner}/${repo_name}/main/webroot/changelog.md"
          
          if grep -q "^update_url=" module.prop; then
            sed -i -E "s|^update_url=.*|update_url=${new_update_url}|" module.prop
          else
            echo "update_url=${new_update_url}" >> module.prop
          fi
          if grep -q "^updateJson=" module.prop; then
            sed -i -E "s|^updateJson=.*|updateJson=${new_update_url}|" module.prop
          else
            echo "updateJson=${new_update_url}" >> module.prop
          fi

          # Write changelog to webroot/changelog.md using latest commit message or user input
          if [ -n "${BODY}" ]; then
            echo "${BODY}" > webroot/changelog.md
          else
            git log -1 --pretty=%B > webroot/changelog.md
          fi

          # prepare latest.json with correct URLs
          zip_url="https://github.com/${REPO}/releases/download/${tag}/${zip_name}"
          # create JSON via Python to safely handle escaping and changelog
          export version=${version}
          export versionCode=${new_vc}
          export download_name=${zip_name}
          export zip_url=${zip_url}
          export changelog_url=${changelog_url}
          python3 - <<'PY' > webroot/latest.json
          import os, json
          data = {
            "id": "coloros16_debloat",
            "name": "ColorOS 16 Debloat (Ads / Cloud / Stats)",
            "version": os.environ.get('version',''),
            "versionCode": int(os.environ.get('versionCode','0')),
            "download_name": os.environ.get('download_name',''),
            "zipUrl": os.environ.get('zip_url',''),
            "zip_url": os.environ.get('zip_url',''),
            "downloadUrl": os.environ.get('zip_url',''),
            "download_url": os.environ.get('zip_url',''),
            "changelog": os.environ.get('changelog_url','')
          }
          print(json.dumps(data, ensure_ascii=False, indent=2))
          PY

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add module.prop webroot/latest.json webroot/changelog.md customize.sh
          git commit -m "chore(release): bump to v${version} (versionCode ${new_vc})" || echo "no changes to commit"
          git push origin HEAD:main || echo "push failed"

          {
            echo "version=${version}"
            echo "zip_name=${zip_name}"
            echo "version_code=${new_vc}"
            echo "tag=${tag}"
          } >> "$GITHUB_OUTPUT"

      - name: Create versioned ZIP package
        env:
          VERSION: ${{ steps.prepare.outputs.version }}
          ZIP_NAME: ${{ steps.prepare.outputs.zip_name }}
        run: |
          # Create a versioned zip of repo root (exclude git & workflows)
          rm -f ColorOS16_Debloat-*.zip
          version=${VERSION:-}
          if [ -z "$version" ]; then
            echo "Missing VERSION metadata from prepare step" >&2
            exit 1
          fi
          zip_name=${ZIP_NAME:-ColorOS16_Debloat-${version}.zip}
          zip -r "$zip_name" . -x "./.git/*" "./.github/*"
          
          echo "Created package: $zip_name"
          ls -lh "$zip_name"

      - name: Create GitHub Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.prepare.outputs.tag }}
          RELEASE_NAME: ${{ github.event.inputs.release_name }}
          BODY: ${{ github.event.inputs.body }}
          PRERELEASE: ${{ github.event.inputs.prerelease }}
        run: |
          set -euo pipefail
          
          tag="${TAG}"
          release_name="${RELEASE_NAME:-${tag}}"
          body="${BODY}"
          prerelease_flag=""
          
          if [ "${PRERELEASE}" = "true" ]; then
            prerelease_flag="--prerelease"
          fi
          
          # If no body provided, use changelog
          if [ -z "$body" ]; then
            body=$(cat webroot/changelog.md)
          fi
          
          # Create release and get upload URL
          gh release create "$tag" \
            --title "$release_name" \
            --notes "$body" \
            $prerelease_flag \
            "${{ steps.prepare.outputs.zip_name }}"
          
          echo "Release created: $tag"
